module test

meta doc '''
# test

Wrapsher test framework

## Usage

Create a program with a suite of tests in it called (by convention)
<code><i>something</i>_test.wsh</code>. You can call it anything,
but you usually might want to organize it as one file per suite,
or one file per program or module.

In this source file, `use module test`. Do not write a `main`
function: the **test** module provides the `main` function.

Any functions in your program that begin with `test_` will
be run. They are expected to be of type **bool** and return
`true` on success and `false` on failure.

**UNIMPLEMENTED:** In the future, instead of nullary functions
**returning bool**, you will accept a **case** argument and return an
****expectation**.

'''

type expectation bool

int main(list args) {
  failures = 0
  shell '''
  # TODO: very ugly raw quick and dirty, with anon funcs and
  # other stuff we can do more reflection in wrapsher
  _wsh_get_global _functions _wsh_funcs
  _wsh_tests=0
  for _wsh_ref in ${_wsh_funcs#list:reflist:}
  do
    # Manually dereferencing
    eval "_wsh_val=\"\${_wshr_${_wsh_ref#ref:}}\""
    # Making our own non-wrapsher list
    case "${_wsh_val#string:}" in test_*)
      _wsh_test_funcs="${_wsh_test_funcs} ${_wsh_val#string:}"
      : $((_wsh_tests++))
    ;;
    esac
  done
  # Doing our own I/O
  echo "1..${_wsh_tests}"
  _wsh_test=0
  _wsh_fails=0
  for _wsh_test_func in ${_wsh_test_funcs}
  do
    : $((_wsh_test++))
    # Blindly calling the nullary form
    # and catching the error, which we don't
    # have yet
    _wsh_dispatch "${_wsh_test_func}" 0
    case "${_wsh_error}" in ?*)
      echo "not ok ${_wsh_test} - ${_wsh_test_func} # ${_wsh_error}"
      : $((_wsh_fails++))
    ;; *)
      case "${_wsh_result}" in 'bool:true')
        echo "ok ${_wsh_test} - ${_wsh_test_func}"
      ;; *)
        echo "not ok ${_wsh_test} - ${_wsh_test_func}"
        : $((_wsh_fails++))
      ;;
      esac
    ;;
    esac
  done
  _wsh_set_local 'failures' "int:${_wsh_fails}"
  '''
  failures
}
