module core
use global refid 1000

type type builtin
type ref builtin
type bool builtin
type int builtin
type string builtin
type reflist builtin
type list reflist

type typeof(any i) {
  shell '''
  _wsh_typeof "${_wshv_i}"
  _wsh_result="type/${_wsh_typeof}"
  '''
}

ref new(type/ref t) {
  bool.new().ref()
}

ref ref(any i) {
  refid = refid + 1
  shell '''
  _wsh_get_local _reflist _wshrl
  _wsh_error="error:Couldn't create reference for value <<${_wshv_i}>>"
  _wsh_get_global refid _wshi
  _wsh_get_local i _wshr_${_wshi#int:}
  _wsh_error=error:
  _wsh_set_local r "ref:${_wshi#int:}"
  '''
  _reflist.push(r)
  r
}

any deref(ref r) {
  shell '''
  _wsh_get_local r _wshi
  echo "deref ${_wshi}" >&2
  _wsh_deref_into "${_wshi}" _wsh_result
  '''
}

bool eq(ref r, ref o) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_get_local o _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

bool new(type/bool t) {
  false
}

bool as_bool(bool p) {
  p
}

int as_int(bool p) {
  if p {
    1
  } else {
    0
  }
}

bool not(bool p) {
  if p {
    false
  } else {
    true
  }
}

bool and(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '&&')
}

bool or(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '||')
}

bool eq(bool p, bool q) {
  shell '''
  _wsh_get_local p _wshi
  _wsh_get_local q _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int new(type/int t) {
  0
}

int as_int(int i) {
  i
}

bool _bool_arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  case "$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))" in 1)
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int _arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  _wsh_result="int:$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))"
  '''
}

bool eq(int a, int b) {
  _bool_arith_op(a, b, '==')
}

bool gt(int a, int b) {
  _bool_arith_op(a, b, '>')
}

bool lt(int a, int b) {
  _bool_arith_op(a, b, '<')
}

int plus(int a, int b) {
  _arith_op(a, b, '+')
}

int minus(int a, int b) {
  _arith_op(a, b, '-')
}

int times(int a, int b) {
  _arith_op(a, b, '*')
}

int div(int a, int b) {
  _arith_op(a, b, '/')
}

int mod(int a, int b) {
  _arith_op(a, b, '%')
}

string to_string(int i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi#int:}"
  '''
}

string new(type/string t) {
  ''
}

string as_string(string s) {
  s
}

bool eq(string s, string o) {
  shell '''
  _wsh_get_local o _wshi
  _wsh_get_local s _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string plus(string s, string o) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local o _wshj
  _wsh_result="${_wshi}${_wshj#string:}"
  '''
}

string times(string s, int i) {
  if i > 1 {
    s + times(s, i - 1)
  } else {
    s
  }
}

int length(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  _wsh_result="int:${#_wshj}"
  '''
}

string head(string s) {
  len = s.length()
  tail_len = len - 1
  pat = '?' * tail_len
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local pat _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wsh_result="string:${_wshi%${_wshj}}"
  '''
}

string tail(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshi="${_wshi#string:}"
  _wsh_result="string:${_wshi#?}"
  '''
}

string at(string s, int i) {
  if i > 0 {
    at(s.tail(), i - 1)
  } else {
    s.head()
  }
}

reflist new(type/reflist t) {
  shell '''
  _wsh_result=reflist:
  '''
}

reflist push(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi}" in reflist:)
    _wsh_result="${_wshi}${_wshj}"
  ;; *)
    _wsh_result="${_wshi} ${_wshj}"
  ;;
  esac
  '''
}

reflist head(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take head() of []"
    return 1
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wsh_result="${_wshj%% *}"
  ;;
  esac
  '''
}

reflist tail(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take tail() of []"
    return 1
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wshk="${_wshj#* }"
    case "${_wshk}" in "${_wshj}")
      _wsh_result=reflist:
    ;; *)
      _wsh_result=reflist:"${_wshk}"
    ;;
    esac
  ;;
  esac
  '''
}

int length(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wshk=0
  case "${_wshi}" in reflist:)
    _wsh_result='int:0'
  ;; *)
    for _wshj in ${_wshi#reflist:}
    do
      : $((_wshk++))
    done
    _wsh_result="int:${_wshk}"
  ;;
  esac
  '''
}

reflist minus(reflist rl, reflist o) {
  if o.length() > 0 {
    rl.delete(o.head()).minus(o.tail())
  } else {
    rl
  }
}

reflist delete(reflist rl, ref r) {
  _delete3(rl, r, reflist.new())
}

reflist _delete3(reflist rl, ref r, reflist out) {
  if rl.length() > 0 {
    if rl.head() == r {
      _delete3(rl.tail(), r, out)
    } else {
      _delete3(rl.tail(), r, out.push(r))
    }
  } else {
    out
  }
}

reflist set_push(reflist rl, ref r) {
  if !rl.has(r) {
    rl.push(r)
  } else {
    rl
  }
}

bool has(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi#reflist:}" in *"${_wshj}"*)
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

string to_string(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_result="string:${_wshi}"
  '''
}

list new(type/list t) {
  shell '''
  _wsh_result=list:
  '''
}

list as_list(list l) {
  l
}

list push(list l, any i) {
  r = i.ref()
  shell '''
  case "${_wshv_l}" in list:)
    "_wsh_result="list:${_wshv_r}"
  ;; *)
    "_wsh_result="${_wshv_l} ${_wshv_r}"
  esac
  '''
}
