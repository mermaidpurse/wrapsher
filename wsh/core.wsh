module core
use global refid 1000

type fun builtin
type type builtin
type ref builtin
type bool builtin
type int builtin
type string builtin
type reflist builtin
type list reflist
type pair reflist
type map reflist

any _typeof(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_typeof "${_wshi}"
  _wsh_get_global "${_wsh_type}" _wsh_result
  '''
}

# Wrap or unwrap a value, coercing it to its derived type (by wrapping
# it, as the target derived type is the storage_type for the target
# type; or by unwrapping it, as the value is of the storage_type of
# the target type; or by leaving it alone, if the value is already of
# the target type. The 'as' argument is a global variable with a type
# value such as `type/list:reflist`. The 'i' is a (type-tagged) value
# to be coerced.
any _as(any i, any as) {
  in = _typeof(i)
  shell '''
  _wsh_get_local i _wsh_i    # 'list:reflist:...'
  _wsh_get_local in _wsh_in  # 'type/list:reflist'
  _wsh_get_local as _wsh_as  # 'type/reflist:builtin'

  case "${_wsh_as%%:*}" in type/*)
    :
  ;; *)
    _wsh_error="error:_as expected a type (e.g. 'type/list:reflist'), got '${_wshl}' at ${_wsh_line}"
    return 1
  ;;
  esac

  # Reduce type types to words
  _wsh_in_storage_type="${_wsh_in#*:}"
  _wsh_in="${_wsh_in%%:*}"
  _wsh_in="${_wsh_in#type/}"

  _wsh_as_storage_type="${_wsh_as#*:}"
  _wsh_as="${_wsh_as%%:*}"
  _wsh_as="${_wsh_as#type/}"

  case "${_wsh_in}" in "${_wsh_as}")
    # target type (${_wsh_in}) is our type (${_wsh_as})--noop
    _wsh_result="${_wsh_i}"
  ;; "${_wsh_as_storage_type}")
    # our type is target's storage type--wrap
    # by adding our type to the value
    _wsh_result="${_wsh_as}:${_wsh_i}"
  ;; *)
    case "${_wsh_in_storage_type}" in "${_wsh_as}")
      # our type's storage type is the target's type--unwrap
      # by removing our type from value
      _wsh_result="${_wsh_i#${_wsh_in}:}"
    ;; *)
      _wsh_error="error: Can't cast ${_wsh_in} value to ${_wsh_as}"
      return 1
    ;;
    esac
  ;;
  esac
  '''
}

string _raw(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi}"
  '''
}

ref new(type/ref t) {
  bool.new().ref()
}

ref ref(any i) {
  refid = refid + 1
  shell '''
  _wsh_get_local _reflist _wshrl
  _wsh_error="error:Couldn't create reference for value <<${_wshv_i}>>"
  _wsh_get_global refid _wshi
  _wsh_get_local i _wshr_${_wshi#int:}
  _wsh_error=error:
  _wsh_set_local r "ref:${_wshi#int:}"
  '''
  _reflist.push(r)
  r
}

any deref(ref r) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_deref_into "${_wshi}" _wsh_result
  '''
}

any call(fun f) {
  shell '''
  _wsh_get_local f _wshi
  _wsh_result="${_wshi#fun:}"
  '''
}

bool eq(ref r, ref o) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_get_local o _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

bool new(type/bool t) {
  false
}

bool as_bool(bool p) {
  p
}

int as_int(bool p) {
  if p {
    1
  } else {
    0
  }
}

bool not(bool p) {
  if p {
    false
  } else {
    true
  }
}

bool and(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '&&')
}

bool or(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '||')
}

bool eq(bool p, bool q) {
  shell '''
  _wsh_get_local p _wshi
  _wsh_get_local q _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int new(type/int t) {
  0
}

int as_int(int i) {
  i
}

bool _bool_arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  case "$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))" in 1)
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int _arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  _wsh_result="int:$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))"
  '''
}

bool eq(int a, int b) {
  _bool_arith_op(a, b, '==')
}

bool gt(int a, int b) {
  _bool_arith_op(a, b, '>')
}

bool lt(int a, int b) {
  _bool_arith_op(a, b, '<')
}

int plus(int a, int b) {
  _arith_op(a, b, '+')
}

int minus(int a, int b) {
  _arith_op(a, b, '-')
}

int times(int a, int b) {
  _arith_op(a, b, '*')
}

int div(int a, int b) {
  _arith_op(a, b, '/')
}

int mod(int a, int b) {
  _arith_op(a, b, '%')
}

string to_string(int i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi#int:}"
  '''
}

string new(type/string t) {
  ''
}

string as_string(string s) {
  s
}

bool eq(string s, string o) {
  shell '''
  _wsh_get_local o _wshi
  _wsh_get_local s _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string plus(string s, string o) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local o _wshj
  _wsh_result="${_wshi}${_wshj#string:}"
  '''
}

string times(string s, int i) {
  if i > 1 {
    s + times(s, i - 1)
  } else {
    if i == 1 {
      s
    } else {
      ''
    }
  }
}

int length(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  _wsh_result="int:${#_wshj}"
  '''
}

string head(string s) {
  len = s.length()
  tail_len = len - 1
  pat = '?' * tail_len
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local pat _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wsh_result="string:${_wshi%${_wshj}}"
  '''
}

string tail(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshi="${_wshi#string:}"
  _wsh_result="string:${_wshi#?}"
  '''
}

string at(string s, int i) {
  if i > 0 {
    at(s.tail(), i - 1)
  } else {
    s.head()
  }
}

reflist new(type/reflist t) {
  shell '''
  _wsh_result=reflist:
  '''
}

reflist push(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi}" in reflist:)
    _wsh_result="${_wshi}${_wshj}"
  ;; *)
    _wsh_result="${_wshi} ${_wshj}"
  ;;
  esac
  '''
}

ref head(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take head() of [] at ${_wsh_line}"
    return 1
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wsh_result="${_wshj%% *}"
  ;;
  esac
  '''
}

reflist tail(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take tail() of [] at ${_wsh_line}"
    return 1
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wshk="${_wshj#* }"
    case "${_wshk}" in "${_wshj}")
      _wsh_result=reflist:
    ;; *)
      _wsh_result=reflist:"${_wshk}"
    ;;
    esac
  ;;
  esac
  '''
}

ref at(reflist rl, int i) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wshj="${_wshj#int:}"
  _wshm='notfound'
  : $((_wshk=0))
  for _wshl in ${_wshi#reflist:}
  do
    case $((_wshk == _wshj)) in 1)
      _wsh_result="${_wshl}"
      _wshm='found'
      break
    ;;
    esac
    : $((_wshk++))
  done
  case "${_wshm}" in notfound)
    _wsh_error="error:array index out of bounds, ${_wshj} > ${_wshk} at ${_wsh_line}"
    return 1
  ;;
  esac
  '''
}

int length(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wshk=0
  case "${_wshi}" in reflist:)
    _wsh_result='int:0'
  ;; *)
    for _wshj in ${_wshi#reflist:}
    do
      : $((_wshk++))
    done
    _wsh_result="int:${_wshk}"
  ;;
  esac
  '''
}

reflist set(reflist rl, int i, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wsh_get_local r _wshk
  _wshl=0
  _wshm=''
  for _wshn in ${_wshi#reflist:}
  do
    case $((_wshl == "${_wshj#int:}")) in 1)
      _wshm="${_wshm}${_wshm:+ }${_wshk}"
    ;; *)
      _wshm="${_wshm}${_wshm:+ }${_wshn}"
    ;;
    esac
  done
  _wsh_result="reflist:${_wshm}"
  '''
}

reflist minus(reflist rl, reflist o) {
  if o.length() > 0 {
    rl.delete(o.head()).minus(o.tail())
  } else {
    rl
  }
}

reflist delete(reflist rl, ref r) {
  _delete3(rl, r, reflist.new())
}

reflist _delete3(reflist rl, ref r, reflist out) {
  if rl.length() > 0 {
    if rl.head() == r {
      _delete3(rl.tail(), r, out)
    } else {
      _delete3(rl.tail(), r, out.push(r))
    }
  } else {
    out
  }
}

reflist set_push(reflist rl, ref r) {
  if !rl.has(r) {
    rl.push(r)
  } else {
    rl
  }
}

bool has(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi#reflist:}" in *"${_wshj}"*)
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

string to_string(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_result="string:${_wshi}"
  '''
}

list as_list(reflist rl) {
  rl._as(list)
}

reflist as_reflist(list l) {
  l._as(reflist)
}

list as_list(list l) {
  l
}

list new(type/list t) {
  reflist.new().as_list()
}

list push(list l, any i) {
  l.as_reflist().push(i.ref()).as_list()
}

any head(list l) {
  l.as_reflist().head().deref()
}

list tail(list l) {
  l.as_reflist().tail().as_list()
}

any at(list l, int i) {
  l.as_reflist().at(i).deref()
}

int length(list l) {
  l.as_reflist().length()
}

bool eq(list l, list o) {
  if l.length() == 0 and o.length() == 0 {
    true
  } else {
    if l.length() != o.length() {
      false
    } else {
      l.tail().eq(o.tail())
    }
  }
}

list map(list l, fun f) {
  _map2(l, f, [])
}

list _map2(list l, fun f, list acc) {
  if l == [] {
    acc
  } else {
    _map2(l.tail(), f, acc.push(f.call().with(l.head())))
  }
}

any find(list l, fun f, any d) {
  if l == [] {
    d
  } else {
    h = l.head()
    if f.call().with(h) {
      h
    } else {
      l.tail().find(f, d)
    }
  }
}

pair new(type/pair t) {
  t.from_kv(false, false)
}

pair from_kv(type/pair t, any k, any v) {
  reflist.new().push(k.ref()).push(v.ref())._as(pair)
}

any key(pair p) {
  p._as(reflist).at(0).deref()
}

any value(pair p) {
  p._as(reflist).at(1).deref()
}

bool eq(pair p, pair o) {
  p.key() == o.key() and p.value() == o.value()
}

string to_string(pair p) {
  p.key().to_string().plus(': ').plus(p.value().to_string())
}

map new(type/map t) {
  reflist.new()._as(map)
}

int length(map m) {
  m._as(reflist).length()
}

map from_pairlist(type/map t, list pl) {
  pl._as(reflist)._as(map)
}

pair head(map m) {
  m._as(reflist).head().deref()._as(pair)
}

map tail(map m) {
  m._as(reflist).tail()._as(map)
}

map push(map m, pair p) {
  m._as(reflist).push(p.ref())._as(map)
}

any at(map m, any k) {
  if m.length() == 0 {
    shell '''
    _wsh_get_local k _wshi
    _wsh_error="error:No such key in map: ${_wshi} at ${_wsh_line}"
    return 1
    '''
  }
  h = m.head()
  if h.key() == k {
    h.value()
  } else {
    m.tail().get(k)
  }
}

bool has(map m, any k) {
  if m.length() == 0 {
    false
  } else {
    if m.head().key() == k {
      true
    } else {
      m.tail().has(k)
    }
  }
}

map set(map m, pair p) {
  m._set3(p, [:])
}

map _set3(map m, pair p, map acc) {
  if m.length() == 0 {
    acc.push(p)
  } else {
    h = m.head()
    if h.key() == p.key() {
      acc.push(p) + m.tail()
    } else {
      acc.push(m.head()) + m.tail()
    }
  }
}
