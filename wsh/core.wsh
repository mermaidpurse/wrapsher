module core

type error builtin
type fun builtin
type type builtin
type ref builtin
type bool builtin
type int builtin
type string builtin
type reflist builtin
type list reflist
type pair reflist
type map reflist

any _typeof(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_typeof "${_wshi}"
  _wsh_get_global "${_wsh_type}" _wsh_result
  '''
}

bool is_a(any i, any as) {
  t = _typeof(i)
  shell '''
  _wsh_get_local i _wshi
  _wsh_get_local as _wshj
  case "${_wshj%:*}" in type/*)
    :
  ;; *)
    _wsh_error="error:is_a expected a type, got '${_wshj}'"
    break
  ;;
  esac
  _wsh_typeof "${_wshi}"
  case "${_wshj%:*}" in type/"${_wsh_type}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string to_string(any i) {
  shell '''
  _wsh_get_local i _wshi
  case "${_wshi}" in type/*)
    _wsh_result="${_wshi%%:*}"
    _wsh_result="${_wsh_result#type/}"
  ;; *)
    _wsh_result="${_wshi#*:}"
  ;;
  esac
  '''
}

bool assert(any i, any as) {
  if !i.is_a(as) {
    throw 'Expected type ' + as.to_string() + ', got ' + _typeof(i).to_string()
  }
}

# Wrap or unwrap a value, coercing it to its derived type (by wrapping
# it, as the target derived type is the storage_type for the target
# type; or by unwrapping it, as the value is of the storage_type of
# the target type; or by leaving it alone, if the value is already of
# the target type. The 'as' argument is a global variable with a type
# value such as `type/list:reflist`. The 'i' is a (type-tagged) value
# to be coerced.
any _as(any i, any as) {
  in = _typeof(i)
  shell '''
  _wsh_get_local i _wsh_i    # 'list:reflist:...'
  _wsh_get_local in _wsh_in  # 'type/list:reflist'
  _wsh_get_local as _wsh_as  # 'type/reflist:builtin'

  case "${_wsh_as%:*}" in type/*)
    :
  ;; *)
    _wsh_error="error:_as expected a type (e.g. 'type/list:reflist'), got '${_wshl}'"
    break
  ;;
  esac

  # Reduce type types to words - type/* types don't get wrapped
  _wsh_in_storage_type="${_wsh_in#*:}"
  _wsh_in="${_wsh_in%:*}"
  _wsh_in="${_wsh_in#type/}"

  _wsh_as_storage_type="${_wsh_as#*:}"
  _wsh_as="${_wsh_as%:*}"
  _wsh_as="${_wsh_as#type/}"

  case "${_wsh_in}" in "${_wsh_as}")
    # target type (${_wsh_in}) is our type (${_wsh_as})--noop
    _wsh_result="${_wsh_i}"
  ;; "${_wsh_as_storage_type}")
    # our type is target's storage type--wrap
    # by adding our type to the value
    _wsh_result="${_wsh_as}+${_wsh_i}"
  ;; *)
    case "${_wsh_in_storage_type}" in "${_wsh_as}")
      # our type's storage type is the target's type--unwrap
      # by removing our type from value
      _wsh_result="${_wsh_i#${_wsh_in}+}"
    ;; *)
      _wsh_error="error: Can't cast ${_wsh_in} value to ${_wsh_as}"
      break
    ;;
    esac
  ;;
  esac
  '''
}

string _raw(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi}"
  '''
}

string quote(any i) {
  i.to_string().quote()
}

error new() {
  shell '''
  _wsh_result='error:'
  '''
}

error as_error(error x) {
  x
}

error as_error(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_result="error:${_wshi#string:}"
  '''
}

error throw(error x) {
  shell '''
  _wsh_get_local x _wsh_error
  break
  '''
}

error throw(string s) {
  throw(s.as_error())
}

error current_error() {
  shell '''
  _wsh_result="error:${_wsh_error#error:}"
  '''
}

string to_string(error x) {
  shell '''
  _wsh_get_local x _wshi
  _wsh_result="string:${_wshi#error:}"
  '''
}

string message(error x) {
  x.to_string().split('
')[0]
}

ref new(type/ref t) {
  bool.new().ref()
}

ref ref(any i) {
  r = false
  shell '''
  _wsh_get_local i _wshi
  _wsh_makeref_into "${_wshi}" _wshr
  _wsh_set_local r "${_wshr}"
  '''
  r
}

any deref(ref r) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_deref_into "${_wshi}" _wsh_result
  '''
}

string to_string(ref r) {
  r._raw()
}

string quote(ref r) {
  'ref('.plus(r.deref().quote()).plus(')')
}

any call(fun f) {
  shell '''
  _wsh_get_local f _wshi
  _wsh_result="${_wshi#fun+}"
  '''
}

bool eq(ref r, ref o) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_get_local o _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

bool new(type/bool t) {
  false
}

bool as_bool(bool p) {
  p
}

int as_int(bool p) {
  if p {
    1
  } else {
    0
  }
}

string to_string(bool p) {
  if p {
    'true'
  } else {
    'false'
  }
}

string quote(bool p) {
  p.to_string()
}

bool not(bool p) {
  if p {
    false
  } else {
    true
  }
}

bool and(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '&&')
}

bool or(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '||')
}

bool eq(bool p, bool q) {
  shell '''
  _wsh_get_local p _wshi
  _wsh_get_local q _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int new(type/int t) {
  0
}

int as_int(int i) {
  i
}

bool _bool_arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  case "$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))" in 1)
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int _arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  _wsh_result="int:$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))"
  '''
}

bool eq(int a, int b) {
  _bool_arith_op(a, b, '==')
}

bool gt(int a, int b) {
  _bool_arith_op(a, b, '>')
}

bool lt(int a, int b) {
  _bool_arith_op(a, b, '<')
}

int plus(int a, int b) {
  _arith_op(a, b, '+')
}

int minus(int a, int b) {
  _arith_op(a, b, '-')
}

int times(int a, int b) {
  _arith_op(a, b, '*')
}

int div(int a, int b) {
  _arith_op(a, b, '/')
}

int mod(int a, int b) {
  _arith_op(a, b, '%')
}

int to_int(string s) {
  if s == '' {
    throw 'can\'t convert empty string to int'
  }

  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  while :; do
    case "${_wshj}" in [\-0-9]*)
      _wshj="${_wshj#?}"
    ;; '')
      _wsh_result="int:${_wshi#string:}"
      break
    ;; *)
      _wsh_error="error:can't convert '${_wshi#string:}' to int"
      break
    ;;
    esac
  done
  '''
}

string to_string(int i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi#int:}"
  '''
}

string quote(int i) {
  i.to_string()
}

string new(type/string t) {
  ''
}

string as_string(string s) {
  s
}

string to_string(string s) {
  s
}

string quote(string s) {
  '\''.plus(s.replace('\\', '\\\\').replace('\'', '\\\'')).plus('\'')
}

string replace(string s, string c, string rep) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wsh_get_local rep _wshk
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wshk="${_wshk#string:}"
  _wshl=''
  _wshm=0
  while
    : $((_wshm++))
  do
    case $((_wshm > 10)) in 1)
      _wsh_error='error:Maximum replacements reached'
      break
    ;;
    esac
    case "${_wshi}" in *"${_wshj}"*)
      case "${_wshl}" in '')
        _wshl="${_wshi%%"${_wshj}"*}${_wshk}"
      ;; *)
        _wshl="${_wshl}${_wshi%%"${_wshj}"*}${_wshk}"
      ;;
      esac
      _wshi="${_wshi#*"${_wshj}"}"
    ;; *)
      case "${_wshl}" in '')
        _wshl="${_wshi}"
      ;; *)
        _wshl="${_wshl}${_wshi}"
      ;;
      esac
      _wshi=''
    ;;
    esac
    case "${_wshi}" in '')
      break
    ;;
    esac
  done
  case "${_wsh_error}" in ?*) break ;; esac
  _wsh_result="string:${_wshl}"
  '''
}

bool eq(string s, string o) {
  shell '''
  _wsh_get_local o _wshi
  _wsh_get_local s _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string plus(string s, string o) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local o _wshj
  _wsh_result="${_wshi}${_wshj#string:}"
  '''
}

string times(string s, int i) {
  if i > 1 {
    s + times(s, i - 1)
  } else {
    if i == 1 {
      s
    } else {
      ''
    }
  }
}

int length(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  _wsh_result="int:${#_wshj}"
  '''
}

string head(string s) {
  len = s.length()
  tail_len = len - 1
  pat = '?' * tail_len
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local pat _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wsh_result="string:${_wshi%${_wshj}}"
  '''
}

string tail(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshi="${_wshi#string:}"
  _wsh_result="string:${_wshi#?}"
  '''
}

string at(string s, int i) {
  if s == '' {
    throw 'index out of bounds: no index ' + i.to_string() + 'in string'
  } else if i > 0 {
      at(s.tail(), i - 1)
  } else {
    s.head()
  }
}

bool has(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  case "${_wshi}" in *"${_wshj}"*)
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

list split(string s, string c) {
  _split3(s, c, [])
}

list _split3(string s, string c, list acc) {
  if s.has(c) {
    h = ''
    t = ''
    shell '''
    _wsh_get_local s _wshi
    _wsh_get_local c _wshj
    _wshi="${_wshi#string:}"
    _wshj="${_wshj#string:}"
    _wsh_set_local h "string:${_wshi%%${_wshj}*}"
    _wsh_result="string:${_wshi#*${_wshj}}"
    _wsh_set_local t "${_wsh_result}"
    '''
    _split3(t, c, acc.push(h))
  } else {
    if s.length() == 0 {
      acc
    } else {
      acc.push(s)
    }
  }
}

string trim(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshk=0
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  while : $((_wshk++))
  do
    case "${_wshi}" in "${_wshj}"*)
      _wshi="${_wshi#"${_wshj}"}"
      continue
    ;;
    esac
    case "${_wshi}" in *"${_wshj}")
      _wshi="${_wshi%"${_wshj}"}"
      continue
    ;;
    esac
    break
  done
  _wsh_result="string:${_wshi}"
  '''
}

reflist new(type/reflist t) {
  shell '''
  _wsh_result=reflist:
  '''
}

reflist push(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi}" in reflist:)
    _wsh_result="${_wshi}${_wshj}"
  ;; *)
    _wsh_result="${_wshi} ${_wshj}"
  ;;
  esac
  '''
}

ref head(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take head() of []"
    break
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wsh_result="${_wshj%% *}"
  ;;
  esac
  '''
}

reflist tail(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take tail() of []"
    break
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wshk="${_wshj#* }"
    case "${_wshk}" in "${_wshj}")
      _wsh_result=reflist:
    ;; *)
      _wsh_result=reflist:"${_wshk}"
    ;;
    esac
  ;;
  esac
  '''
}

ref at(reflist rl, int i) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wshj="${_wshj#int:}"
  _wshm='notfound'
  : $((_wshk=0))
  for _wshl in ${_wshi#reflist:}
  do
    case $((_wshk == _wshj)) in 1)
      _wsh_result="${_wshl}"
      _wshm='found'
      break
    ;;
    esac
    : $((_wshk++))
  done
  case "${_wshm}" in notfound)
    _wsh_error="error:index out of bounds, ${_wshj} > $((_wshk - 1))"
    break
  ;;
  esac
  '''
}

int length(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wshk=0
  case "${_wshi}" in reflist:)
    _wsh_result='int:0'
  ;; *)
    for _wshj in ${_wshi#reflist:}
    do
      : $((_wshk++))
    done
    _wsh_result="int:${_wshk}"
  ;;
  esac
  '''
}

reflist set(reflist rl, int i, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wsh_get_local r _wshk
  _wshl=0
  _wshm=''
  for _wshn in ${_wshi#reflist:}
  do
    case $((_wshl == "${_wshj#int:}")) in 1)
      _wshm="${_wshm}${_wshm:+ }${_wshk}"
    ;; *)
      _wshm="${_wshm}${_wshm:+ }${_wshn}"
    ;;
    esac
  done
  _wsh_result="reflist:${_wshm}"
  '''
}

reflist map(reflist rl, fun f) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local f _wshj
  _wshv=
  for _wshk in ${_wshi#reflist:}
  do
    _wsh_set_local i "${_wshk}"
  '''
    r = f.call().with(i)
  shell '''
    _wsh_get_local r _wshr
    _wshv="${_wshv:-reflist:}${_wshv:+ }${_wshr}"
  done
  _wsh_result="${_wshv}"
  '''
}

reflist minus(reflist rl, reflist o) {
  if o.length() > 0 {
    rl.delete(o.head()).minus(o.tail())
  } else {
    rl
  }
}

reflist delete(reflist rl, ref r) {
  _delete3(rl, r, reflist.new())
}

reflist _delete3(reflist rl, ref r, reflist out) {
  if rl.length() > 0 {
    if rl.head() == r {
      _delete3(rl.tail(), r, out)
    } else {
      _delete3(rl.tail(), r, out.push(r))
    }
  } else {
    out
  }
}

reflist set_push(reflist rl, ref r) {
  if !rl.has(r) {
    rl.push(r)
  } else {
    rl
  }
}

bool has(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi#reflist:}" in *"${_wshj}"*)
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

string to_string(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_result="string:${_wshi}"
  '''
}

list as_list(reflist rl) {
  rl._as(list)
}

reflist as_reflist(list l) {
  l._as(reflist)
}

list as_list(list l) {
  l
}

list new(type/list t) {
  reflist.new().as_list()
}

list push(list l, any i) {
  l.as_reflist().push(i.ref()).as_list()
}

any head(list l) {
  l.as_reflist().head().deref()
}

list tail(list l) {
  l.as_reflist().tail().as_list()
}

any at(list l, int i) {
  l.as_reflist().at(i).deref()
}

int length(list l) {
  l.as_reflist().length()
}

bool eq(list l, list o) {
  if l.length() == 0 and o.length() == 0 {
    true
  } else {
    if l.length() != o.length() {
      false
    } else {
      l.tail().eq(o.tail())
    }
  }
}

list map(list l, fun f) {
  rf = ref fun(ref r) {
    f.call().with(r.deref()).ref()
  }
  l.as_reflist().map(rf).as_list()
}

list _map2(list l, fun f, list acc) {
  if l == [] {
    acc
  } else {
    _map2(l.tail(), f, acc.push(f.call().with(l.head())))
  }
}

string join(list l, string c) {
  if l.length() == 0 {
    ''
  } else {
    _list3(l.tail(), c, l.head().to_string())
  }
}

string _list3(list l, string c, string acc) {
  if l.length() == 0 {
    acc
  } else {
    _list3(l.tail(), c, acc.plus(c).plus(l.head().to_string()))
  }
}

string to_string(list l) {
  '['.plus(l.map(string fun (any i) { i.to_string() }).join(', ')).plus(']')
}

string quote(list l) {
  '['.plus(l.map(string fun (any i) { i.quote() }).join(', ')).plus(']')
}

any find(list l, fun f, any d) {
  if l == [] {
    d
  } else {
    h = l.head() 
    if f.call().with(h) {
      h
    } else {
      l.tail().find(f, d)
    }
  }
}

bool has(list l, any i) {
  if l == [] {
    false
  } else {
    h = l.head()
    if h == i {
      true
    } else {
      l.tail().has(i)
    }
  }
}

bool any(list l, fun f) {
  if l == [] {
    false
  } else {
    if f.call().with(l.head()) {
      true
    } else {
      l.tail().any(f)
    }
  }
}

bool all(list l, fun f) {
  if l == [] {
    true
  } else {
    if f.call().with(l.head()) {
      l.tail().all(f)
    } else {
      false
    }
  }
}

pair new(type/pair t) {
  t.from_kv(false, false)
}

pair from_kv(type/pair t, any k, any v) {
  reflist.new().push(k.ref()).push(v.ref())._as(pair)
}

any key(pair p) {
  p._as(reflist).at(0).deref()
}

any value(pair p) {
  p._as(reflist).at(1).deref()
}

bool eq(pair p, pair o) {
  p.key() == o.key() and p.value() == o.value()
}

string to_string(pair p) {
  p.key().to_string() + ': ' + p.value().to_string()
}

string quote(pair p) {
  p.key().quote() + ': ' + p.value().to_string()
}

map new(type/map t) {
  reflist.new()._as(map)
}

int length(map m) {
  m._as(reflist).length()
}

map from_pairlist(type/map t, list pl) {
  pl._as(reflist)._as(map)
}

map as_map(list l) {
  if l.all(bool fun (pair p) { true }) {
    map.from_pairlist(l)
  } else {
    throw 'not all list elements are pairs'
  }
}

list as_pairlist(map m) {
  m._as(reflist)._as(list)
}

pair head(map m) {
  m._as(reflist).head().deref()._as(pair)
}

map tail(map m) {
  m._as(reflist).tail()._as(map)
}

map push(map m, pair p) {
  m._as(reflist).push(p.ref())._as(map)
}

any at(map m, any k) {
  if m.length() == 0 {
    shell '''
    _wsh_get_local k _wshi
    _wsh_error="error:No such key in map: ${_wshi}"
    break
    '''
  }
  h = m.head()

  if h.key() == k {
    h.value()
  } else {
    m.tail().at(k)
  }
}

bool has(map m, any k) {
  if m.length() == 0 {
    false
  } else {
    if m.head().key() == k {
      true
    } else {
      m.tail().has(k)
    }
  }
}

string to_string(map m) {
  if m.length() == 0 {
    '[:]'
  } else {
    m.as_pairlist().to_string()
  }
}

string quote(map m) {
  if m.length() == 0 {
    '[:]'
  } else {
    m.as_pairlist().quote()
  }
}

map set(map m, pair p) {
  m._set3(p, [:])
}

map _set3(map m, pair p, map acc) {
  if m.length() == 0 {
    acc.push(p)
  } else {
    h = m.head()
    if h.key() == p.key() {
      acc.push(p) + m.tail()
    } else {
      acc.push(m.head()) + m.tail()
    }
  }
}

