module core

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# Copyright (c) 2025 Mermaidpurse

meta doc '''
# core

Wrapsher language core

## Usage

This module is implicitly `use`-ed in every Wrapsher program; there is
no need to `use module core`. It contains functions that operate on all
the core language types and provides several other utilities and types.

## Types

### `program_info`

An fstruct describing information about the currently-compiled program.

```wrapsher
string name(program_info pi) { }
string location(program_info pi) { }
program_info set_name(program_info pi, string name) { }
program_info set_location(program_info, string location) { }
```

### `command_info`

An fstruct describing information about a command.

```wrapsher
string name(command_info ci) { }
string location(command_info ci) { }
string is_external(command_info ci) { }
string is_available(command_info ci) { }
```

Use the `command_info get(type/command_info t, string name)` to get information
about a command.

Use the `command_info need(type/command_info t, string name)` to get information
about a cammond, and throw an error if the command is not available.

### `command_result`

An fstruct describing the results of running a command.

```wrapsher
int exitcode(command_result cr) { }
string output(command_result cr) { }
list lines(command_result cr) { }
bool is_success(command_result cr) { }
```

Run a command and get its output with the `command_result run(command_info ci, list args)`
function. The `args` argument is passed to the command on its command line.

## Global Variables

- `program_info program`: Information about the currently-compiled program
- `list externals`: list of `command_info`, information about external commands

'''
type error builtin
type fun builtin
type type builtin
type ref builtin
type bool builtin
type int builtin
type string builtin
type reflist builtin
type list reflist
type pair reflist
type map reflist
type program_info list
type command_info list
type command_result list

use global program ''
use global externals ''

bool init(module/core m) {
  program = program_info.new()
  location = ''
  shell '''
  _wsh_set_local location "string:${0}"
  '''
  program = program.set_location(location)

  externals = _externals.map(command_info fun (string n) {
      command_info.need(n)
    })

  true
}

# command_result is an fstruct
# 0 - exitcode
# 1 - output (raw without trailing newline)
command_result new(type/command_result t) {
  list.new().push(0).push('')._as(command_result)
}

int exitcode(command_result cr) {
  cr._as(list).at(0)
}

command_result set_exitcode(command_result cr, int exitcode) {
  cr._as(list).set(0, exitcode)._as(command_result)
}

string output(command_result cr) {
  cr._as(list).at(1)
}

command_result set_output(command_result cr, string output) {
  cr._as(list).set(1, output)._as(command_result)
}

list lines(command_result cr) {
  cr.output().split('
')
}

bool is_success(command_result cr) {
  cr.exitcode() == 0
}

string to_string(command_result cr) {
  [
    'exitcode': cr.exitcode(),
    'output': cr.output()
  ].to_string()
}

string quote(command_result cr) {
  cr._as(list).quote()
}

# command_info is an fstruct
# 0 - name
# 1 - location
# 2 - is_external
# 3 - is_available
command_info new(type/command_info t) {
  ci = list.new().push('').push('').push(false).push(false)._as(command_info)
}

string to_string(command_info ci) {
  [
    'name': ci.name(),
    'location': ci.location(),
    'is_external': ci.is_external(),
    'is_available': ci.is_available()
  ].to_string()
}

string quote(command_info ci) {
  ci._as(list).quote()
}

command_info get(type/command_info t, string command_name) {
  ci = command_info.new()
  ci = ci.set_name(command_name)
  loc = ''
  is_external = false
  is_available = false
  shell '''
  _wsh_get_local command_name _wshi
  _wshi="${_wshi#string:}"
  _wshj="$(command -v "${_wshi}" 2>&1)"
  _wshk="${?}"
  case "${_wshk}" in 0)
    _wsh_set_local is_available "bool:true"
    case "${_wshj}" in alias*)
      _wsh_set_local loc "string:${_wshi}"
      _wsh_set_local is_external "bool:true" # assume aliases are external, which is actually a bad assumption
    ;; "${_wshi}")
      _wsh_set_local loc "string:${_wshj}"
      _wsh_set_local is_external "bool:false"
    ;; */*)
      _wsh_set_local loc "string:${_wshj}"
      _wsh_set_local is_external "bool:true"
      # Assume the worst--the alternative is
      # to (deeply) walk the alias chain
      _wsh_set_local is_external "bool:true"
    ;; *)
      _wsh_error="error:internal error running 'command -v ${_wshi}'"
      break
    ;;
    esac
  ;; *)
    _wsh_set_local is_available "bool:false"
  ;;
  esac
  '''
  ci = ci.set_location(loc)
  ci = ci.set_is_external(is_external)
  ci = ci.set_is_available(is_available)
}

command_info need(type/command_info t, string command_name) {
  ci = command_info.get(command_name)
  if !ci.is_available() {
    throw 'required command \'' + command_name + '\' is unavailable'
  }
  if ci.is_external() and !_feature_external {
    throw 'required command \'' + command_name + '\' is external but \'use feature external\' is not in effect'
  }
  ci
}

command_result run(command_info ci, list args) {
  if !ci.is_available() {
    throw 'command \'' + ci.name() + '\' is not available'
  }
  if ci.is_external() and !_feature_external {
    throw 'command \'' + ci.name() + '\' is external but \'use feature external\' is not in effect'
  }
  if !args.all(bool fun (string s) { s.is_a(string) }) {
    throw 'can\'t pass non-string arguments to system commands'
  }
  rl = args.as_reflist()
  loc = ci.location()
  exitcode = 0
  output = ''
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local loc _wshj
  _wshk=0
  _wsh_command_line="_wsh_raw_result=\"\$(\"${_wshj#string:}\""
  for _wshl in ${_wshi#reflist:}
  do
    _wsh_deref_into "${_wshl}" "_wsh_command_arg${_wshk}"
    _wsh_command_line="${_wsh_command_line} \"\${_wsh_command_arg${_wshk}#string:}\""
    : $((_wshk++))
  done
  _wsh_command_line="${_wsh_command_line})\""
  eval "${_wsh_command_line}"
  _wsh_set_local exitcode "int:$?"
  _wsh_set_local output "string:${_wsh_raw_result}"
  '''
  cr = command_result.new()
  cr = cr.set_exitcode(exitcode)
  cr = cr.set_output(output)
}

string name(command_info ci) {
  ci._as(list).at(0)
}

string location(command_info ci) {
  ci._as(list).at(1)
}

bool is_external(command_info ci) {
  ci._as(list).at(2)
}

bool is_available(command_info ci) {
  ci._as(list).at(3)
}

command_info set_name(command_info ci, string name) {
  ci._as(list).set(0, name)._as(command_info)
}

command_info set_location(command_info ci, string loc) {
  ci._as(list).set(1, loc)._as(command_info)
}

command_info set_is_external(command_info ci, bool is_external) {
  ci._as(list).set(2, is_external)._as(command_info)
}

command_info set_is_available(command_info ci, bool is_available) {
  ci._as(list).set(3, is_available)._as(command_info)
}


# program_info is an fstruct
# 0 - location
program_info new(type/program_info pi) {
  pi = list.new().push('')._as(program_info)
}

string location(program_info pi) {
  pi._as(list).at(0)
}

program_info set_location(program_info pi, string loc) {
  pi._as(list).set(0, loc)._as(program_info)
}

any _typeof(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_typeof "${_wshi}"
  _wsh_get_global "${_wsh_type}" _wsh_result
  '''
}

bool is_a(any i, any as) {
  t = _typeof(i)
  shell '''
  _wsh_get_local i _wshi
  _wsh_get_local as _wshj
  case "${_wshj%:*}" in type/*)
    :
  ;; *)
    _wsh_error="error:is_a expected a type, got '${_wshj}'"
    break
  ;;
  esac
  _wsh_typeof "${_wshi}"
  case "${_wshj%:*}" in type/"${_wsh_type}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string to_string(any i) {
  shell '''
  _wsh_get_local i _wshi
  case "${_wshi}" in type/*)
    _wsh_result="${_wshi%%:*}"
    _wsh_result="${_wsh_result#type/}"
  ;; *)
    _wsh_result="${_wshi#*:}"
  ;;
  esac
  '''
}

bool assert(any i, any as) {
  if !i.is_a(as) {
    throw 'Expected type ' + as.to_string() + ', got ' + _typeof(i).to_string()
  }
}

# Wrap or unwrap a value, coercing it to its derived type (by wrapping
# it, as the target derived type is the storage_type for the target
# type; or by unwrapping it, as the value is of the storage_type of
# the target type; or by leaving it alone, if the value is already of
# the target type. The 'as' argument is a global variable with a type
# value such as `type/list:reflist`. The 'i' is a (type-tagged) value
# to be coerced.
any _as(any i, any as) {
  in = _typeof(i)
  shell '''
  _wsh_get_local i _wsh_i    # 'list:reflist:...'
  _wsh_get_local in _wsh_in  # 'type/list:reflist'
  _wsh_get_local as _wsh_as  # 'type/reflist:builtin'

  case "${_wsh_as%:*}" in type/*)
    :
  ;; *)
    _wsh_error="error:_as expected a type (e.g. 'type/list:reflist'), got '${_wshl}'"
    break
  ;;
  esac

  # Reduce type types to words - type/* types don't get wrapped
  _wsh_in_storage_type="${_wsh_in#*:}"
  _wsh_in="${_wsh_in%:*}"
  _wsh_in="${_wsh_in#type/}"

  _wsh_as_storage_type="${_wsh_as#*:}"
  _wsh_as="${_wsh_as%:*}"
  _wsh_as="${_wsh_as#type/}"

  case "${_wsh_in}" in "${_wsh_as}")
    # target type (${_wsh_in}) is our type (${_wsh_as})--noop
    _wsh_result="${_wsh_i}"
  ;; "${_wsh_as_storage_type}")
    # our type is target's storage type--wrap
    # by adding our type to the value
    _wsh_result="${_wsh_as}+${_wsh_i}"
  ;; *)
    case "${_wsh_in_storage_type}" in "${_wsh_as}")
      # our type's storage type is the target's type--unwrap
      # by removing our type from value
      _wsh_result="${_wsh_i#${_wsh_in}+}"
    ;; *)
      _wsh_error="error: Can't cast ${_wsh_in} value to ${_wsh_as}"
      break
    ;;
    esac
  ;;
  esac
  '''
}

string _raw(any i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi}"
  '''
}

string quote(any i) {
  i.to_string().quote()
}

error new() {
  shell '''
  _wsh_result='error:'
  '''
}

error as_error(error x) {
  x
}

error as_error(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_result="error:${_wshi#string:}"
  '''
}

error throw(error x) {
  shell '''
  _wsh_get_local x _wsh_error
  break
  '''
}

error throw(string s) {
  throw(s.as_error())
}

error current_error() {
  shell '''
  _wsh_result="error:${_wsh_error#error:}"
  '''
}

string to_string(error x) {
  shell '''
  _wsh_get_local x _wshi
  _wsh_result="string:${_wshi#error:}"
  '''
}

string message(error x) {
  x.to_string().split('
')[0]
}

ref new(type/ref t) {
  bool.new().ref()
}

ref ref(any i) {
  r = false
  shell '''
  _wsh_get_local i _wshi
  _wsh_makeref_into "${_wshi}" _wshr
  _wsh_set_local r "${_wshr}"
  '''
  r
}

any deref(ref r) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_deref_into "${_wshi}" _wsh_result
  '''
}

string to_string(ref r) {
  r._raw()
}

string quote(ref r) {
  'ref('.plus(r.deref().quote()).plus(')')
}

any call(fun f) {
  shell '''
  _wsh_get_local f _wshi
  _wsh_result="${_wshi#fun+}"
  '''
}

bool eq(ref r, ref o) {
  shell '''
  _wsh_get_local r _wshi
  _wsh_get_local o _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

bool new(type/bool t) {
  false
}

bool as_bool(bool p) {
  p
}

int as_int(bool p) {
  if p {
    1
  } else {
    0
  }
}

string to_string(bool p) {
  if p {
    'true'
  } else {
    'false'
  }
}

string quote(bool p) {
  p.to_string()
}

bool not(bool p) {
  if p {
    false
  } else {
    true
  }
}

bool and(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '&&')
}

bool or(bool p, bool q) {
  _bool_arith_op(p.as_int(), q.as_int(), '||')
}

bool eq(bool p, bool q) {
  shell '''
  _wsh_get_local p _wshi
  _wsh_get_local q _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int new(type/int t) {
  0
}

int as_int(int i) {
  i
}

bool _bool_arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  case "$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))" in 1)
    _wsh_result=bool:true
  ;;
  *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

int _arith_op(int a, int b, string op) {
  shell '''
  _wsh_get_local a _wshi
  _wsh_get_local b _wshj
  _wsh_get_local op _wshk
  _wsh_result="int:$((${_wshi#int:} ${_wshk#string:} ${_wshj#int:}))"
  '''
}

bool eq(int a, int b) {
  _bool_arith_op(a, b, '==')
}

bool gt(int a, int b) {
  _bool_arith_op(a, b, '>')
}

bool lt(int a, int b) {
  _bool_arith_op(a, b, '<')
}

int plus(int a, int b) {
  _arith_op(a, b, '+')
}

int minus(int a, int b) {
  _arith_op(a, b, '-')
}

int times(int a, int b) {
  _arith_op(a, b, '*')
}

int div(int a, int b) {
  _arith_op(a, b, '/')
}

int mod(int a, int b) {
  _arith_op(a, b, '%')
}

int to_int(string s) {
  if s == '' {
    throw 'can\'t convert empty string to int'
  }

  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  while :; do
    case "${_wshj}" in [\-0-9]*)
      _wshj="${_wshj#?}"
    ;; '')
      _wsh_result="int:${_wshi#string:}"
      break
    ;; *)
      _wsh_error="error:can't convert '${_wshi#string:}' to int"
      break
    ;;
    esac
  done
  '''
}

string to_string(int i) {
  shell '''
  _wsh_get_local i _wshi
  _wsh_result="string:${_wshi#int:}"
  '''
}

string quote(int i) {
  i.to_string()
}

string new(type/string t) {
  ''
}

string as_string(string s) {
  s
}

string to_string(string s) {
  s
}

string quote(string s) {
  '\''.plus(s.replace('\\', '\\\\').replace('\'', '\\\'')).plus('\'')
}

string replace(string s, string c, string rep) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wsh_get_local rep _wshk
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wshk="${_wshk#string:}"
  _wshl=''
  _wshm=0
  while
    : $((_wshm++))
  do
    case $((_wshm > 10)) in 1)
      _wsh_error='error:Maximum replacements reached'
      break
    ;;
    esac
    case "${_wshi}" in *"${_wshj}"*)
      case "${_wshl}" in '')
        _wshl="${_wshi%%"${_wshj}"*}${_wshk}"
      ;; *)
        _wshl="${_wshl}${_wshi%%"${_wshj}"*}${_wshk}"
      ;;
      esac
      _wshi="${_wshi#*"${_wshj}"}"
    ;; *)
      case "${_wshl}" in '')
        _wshl="${_wshi}"
      ;; *)
        _wshl="${_wshl}${_wshi}"
      ;;
      esac
      _wshi=''
    ;;
    esac
    case "${_wshi}" in '')
      break
    ;;
    esac
  done
  case "${_wsh_error}" in ?*) break ;; esac
  _wsh_result="string:${_wshl}"
  '''
}

bool eq(string s, string o) {
  shell '''
  _wsh_get_local o _wshi
  _wsh_get_local s _wshj
  case "${_wshi}" in "${_wshj}")
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

string plus(string s, string o) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local o _wshj
  _wsh_result="${_wshi}${_wshj#string:}"
  '''
}

string times(string s, int i) {
  if i > 1 {
    s + times(s, i - 1)
  } else {
    if i == 1 {
      s
    } else {
      ''
    }
  }
}

int length(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshj="${_wshi#string:}"
  _wsh_result="int:${#_wshj}"
  '''
}

string head(string s) {
  len = s.length()
  tail_len = len - 1
  pat = '?' * tail_len
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local pat _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  _wsh_result="string:${_wshi%${_wshj}}"
  '''
}

string tail(string s) {
  shell '''
  _wsh_get_local s _wshi
  _wshi="${_wshi#string:}"
  _wsh_result="string:${_wshi#?}"
  '''
}

string at(string s, int i) {
  if s == '' {
    throw 'index out of bounds: no index ' + i.to_string() + 'in string'
  } else if i > 0 {
      at(s.tail(), i - 1)
  } else {
    s.head()
  }
}

bool has(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  case "${_wshi}" in *"${_wshj}"*)
    _wsh_result='bool:true'
  ;; *)
    _wsh_result='bool:false'
  ;;
  esac
  '''
}

bool has_prefix(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  case "${_wshi}" in "${_wshj}"*)
    _wsh_result="bool:true"
  ;; *)
    _wsh_result="bool:false"
  ;;
  esac
  '''
}

bool has_suffix(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  case "${_wshi}" in *"${_wshj}")
    _wsh_result="bool:true"
  ;; *)
    _wsh_result="bool:false"
  ;;
  esac
  '''
}

list split(string s, string c) {
  _split3(s, c, [])
}

list _split3(string s, string c, list acc) {
  if s.has(c) {
    h = ''
    t = ''
    shell '''
    _wsh_get_local s _wshi
    _wsh_get_local c _wshj
    _wshi="${_wshi#string:}"
    _wshj="${_wshj#string:}"
    _wsh_set_local h "string:${_wshi%%${_wshj}*}"
    _wsh_result="string:${_wshi#*${_wshj}}"
    _wsh_set_local t "${_wsh_result}"
    '''
    _split3(t, c, acc.push(h))
  } else {
    if s.length() == 0 {
      acc
    } else {
      acc.push(s)
    }
  }
}

string trim(string s, string c) {
  shell '''
  _wsh_get_local s _wshi
  _wsh_get_local c _wshj
  _wshk=0
  _wshi="${_wshi#string:}"
  _wshj="${_wshj#string:}"
  while : $((_wshk++))
  do
    case "${_wshi}" in "${_wshj}"*)
      _wshi="${_wshi#"${_wshj}"}"
      continue
    ;;
    esac
    case "${_wshi}" in *"${_wshj}")
      _wshi="${_wshi%"${_wshj}"}"
      continue
    ;;
    esac
    break
  done
  _wsh_result="string:${_wshi}"
  '''
}

reflist new(type/reflist t) {
  shell '''
  _wsh_result=reflist:
  '''
}

reflist push(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi}" in reflist:)
    _wsh_result="${_wshi}${_wshj}"
  ;; *)
    _wsh_result="${_wshi} ${_wshj}"
  ;;
  esac
  '''
}

ref head(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take head() of []"
    break
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wsh_result="${_wshj%% *}"
  ;;
  esac
  '''
}

reflist tail(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  case "${_wshi}" in reflist:)
    _wsh_error="error:attempted to take tail() of []"
    break
  ;; *)
    _wshj="${_wshi#reflist:}"
    _wshk="${_wshj#* }"
    case "${_wshk}" in "${_wshj}")
      _wsh_result=reflist:
    ;; *)
      _wsh_result=reflist:"${_wshk}"
    ;;
    esac
  ;;
  esac
  '''
}

ref at(reflist rl, int i) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wshj="${_wshj#int:}"
  _wshm='notfound'
  : $((_wshk=0))
  for _wshl in ${_wshi#reflist:}
  do
    case $((_wshk == _wshj)) in 1)
      _wsh_result="${_wshl}"
      _wshm='found'
      break
    ;;
    esac
    : $((_wshk++))
  done
  case "${_wshm}" in notfound)
    _wsh_error="error:index out of bounds, ${_wshj} > $((_wshk - 1))"
    break
  ;;
  esac
  '''
}

int length(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wshk=0
  case "${_wshi}" in reflist:)
    _wsh_result='int:0'
  ;; *)
    for _wshj in ${_wshi#reflist:}
    do
      : $((_wshk++))
    done
    _wsh_result="int:${_wshk}"
  ;;
  esac
  '''
}

reflist set(reflist rl, int i, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local i _wshj
  _wsh_get_local r _wshk
  _wshl=0
  _wshm=''
  _wshj="${_wshj#int:}"
  for _wshn in ${_wshi#reflist:}
  do
    case $((_wshl == _wshj)) in 1)
      _wshm="${_wshm}${_wshm:+ }${_wshk}"
    ;; *)
      _wshm="${_wshm}${_wshm:+ }${_wshn}"
    ;;
    esac
    : $((_wshl++))
  done
  _wsh_result="reflist:${_wshm}"
  '''
}

reflist minus(reflist rl, reflist o) {
  if o.length() > 0 {
    rl.delete(o.head()).minus(o.tail())
  } else {
    rl
  }
}

reflist delete(reflist rl, ref r) {
  _delete3(rl, r, reflist.new())
}

reflist _delete3(reflist rl, ref r, reflist out) {
  if rl.length() > 0 {
    if rl.head() == r {
      _delete3(rl.tail(), r, out)
    } else {
      _delete3(rl.tail(), r, out.push(r))
    }
  } else {
    out
  }
}

reflist set_push(reflist rl, ref r) {
  if !rl.has(r) {
    rl.push(r)
  } else {
    rl
  }
}

bool has(reflist rl, ref r) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_get_local r _wshj
  case "${_wshi#reflist:}" in *"${_wshj}"*)
    _wsh_result=bool:true
  ;; *)
    _wsh_result=bool:false
  ;;
  esac
  '''
}

string to_string(reflist rl) {
  shell '''
  _wsh_get_local rl _wshi
  _wsh_result="string:${_wshi}"
  '''
}

list as_list(reflist rl) {
  rl._as(list)
}

reflist as_reflist(list l) {
  l._as(reflist)
}

list as_list(list l) {
  l
}

list new(type/list t) {
  reflist.new().as_list()
}

list push(list l, any i) {
  l.as_reflist().push(i.ref()).as_list()
}

any head(list l) {
  l.as_reflist().head().deref()
}

list tail(list l) {
  l.as_reflist().tail().as_list()
}

any at(list l, int i) {
  l.as_reflist().at(i).deref()
}

int length(list l) {
  l.as_reflist().length()
}

list set(list l, int i, any v) {
  l.as_reflist().set(i, v.ref()).as_list()
}

bool eq(list l, list o) {
  if l.length() == 0 and o.length() == 0 {
    true
  } else {
    if l.length() != o.length() {
      false
    } else {
      l.head() == o.head() and l.tail().eq(o.tail())
    }
  }
}

list map(list l, fun f) {
  _map2(l, f, [])
}

list _map2(list l, fun f, list acc) {
  if l == [] {
    acc
  } else {
    _map2(l.tail(), f, acc.push(f.call().with(l.head())))
  }
}

string join(list l, string c) {
  if l.length() == 0 {
    ''
  } else {
    _list3(l.tail(), c, l.head().to_string())
  }
}

string _list3(list l, string c, string acc) {
  if l.length() == 0 {
    acc
  } else {
    _list3(l.tail(), c, acc.plus(c).plus(l.head().to_string()))
  }
}

string to_string(list l) {
  inner = l.map(string fun (any i) { i.to_string() }).join(', ')
  '['+ inner + ']'
}

string quote(list l) {
  '['.plus(l.map(string fun (any i) { i.quote() }).join(', ')).plus(']')
}

any find(list l, fun f, any d) {
  if l == [] {
    d
  } else {
    h = l.head() 
    if f.call().with(h) {
      h
    } else {
      l.tail().find(f, d)
    }
  }
}

bool has(list l, any i) {
  if l == [] {
    false
  } else {
    h = l.head()
    if h == i {
      true
    } else {
      l.tail().has(i)
    }
  }
}

bool any(list l, fun f) {
  if l == [] {
    false
  } else {
    if f.call().with(l.head()) {
      true
    } else {
      l.tail().any(f)
    }
  }
}

bool all(list l, fun f) {
  if l == [] {
    true
  } else {
    if f.call().with(l.head()) {
      l.tail().all(f)
    } else {
      false
    }
  }
}

pair new(type/pair t) {
  t.from_kv(false, false)
}

pair from_kv(type/pair t, any k, any v) {
  reflist.new().push(k.ref()).push(v.ref())._as(pair)
}

any key(pair p) {
  p._as(reflist).at(0).deref()
}

any value(pair p) {
  p._as(reflist).at(1).deref()
}

bool eq(pair p, pair o) {
  p.key() == o.key() and p.value() == o.value()
}

string to_string(pair p) {
  p.key().to_string() + ': ' + p.value().to_string()
}

string quote(pair p) {
  p.key().quote() + ': ' + p.value().to_string()
}

map new(type/map t) {
  reflist.new()._as(map)
}

int length(map m) {
  m._as(reflist).length()
}

map from_pairlist(type/map t, list pl) {
  pl._as(reflist)._as(map)
}

map as_map(list l) {
  if l.all(bool fun (pair p) { true }) {
    map.from_pairlist(l)
  } else {
    throw 'not all list elements are pairs'
  }
}

list as_pairlist(map m) {
  m._as(reflist)._as(list)
}

pair head(map m) {
  m._as(reflist).head().deref()._as(pair)
}

map tail(map m) {
  m._as(reflist).tail()._as(map)
}

map push(map m, pair p) {
  m._as(reflist).push(p.ref())._as(map)
}

any at(map m, any k) {
  if m.length() == 0 {
    shell '''
    _wsh_get_local k _wshi
    _wsh_error="error:No such key in map: ${_wshi}"
    break
    '''
  }
  h = m.head()

  if h.key() == k {
    h.value()
  } else {
    m.tail().at(k)
  }
}

bool has(map m, any k) {
  if m.length() == 0 {
    false
  } else {
    if m.head().key() == k {
      true
    } else {
      m.tail().has(k)
    }
  }
}

string to_string(map m) {
  if m.length() == 0 {
    '[:]'
  } else {
    m.as_pairlist().to_string()
  }
}

string quote(map m) {
  if m.length() == 0 {
    '[:]'
  } else {
    m.as_pairlist().quote()
  }
}

map set(map m, pair p) {
  m._set3(p, [:])
}

map _set3(map m, pair p, map acc) {
  if m.length() == 0 {
    acc.push(p)
  } else {
    h = m.head()
    if h.key() == p.key() {
      acc.push(p) + m.tail()
    } else {
      acc.push(m.head()) + m.tail()
    }
  }
}

