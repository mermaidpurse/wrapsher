meta doc 'tests for core module'

use module io
use module test

bool test_bool_new() {
  b = bool.new()
  not b
}

bool test_bool_quote() {
  bool.new().quote() == 'false'
}

bool test_bool_and() {
  true and true
}

bool test_string_new() {
  string.new() == ''
}

bool test_string_quote() {
  'one'.quote() == '\'one\''
}

bool test_string_quote_with_quotes() {
  e = '\'\\\'one\\\'\\\\ \\\'two\\\'\''
  g = '\'one\'\\ \'two\''.quote()
  g == e
}

bool test_string_eq_same() {
  'same' == 'same'
}

bool test_string_times_0() {
  '' == 'one' * 0
}

bool test_string_times_1() {
  'one' == 'one' * 1
}

bool test_string_times_2() {
  'oneone' == 'one' * 2
}

bool test_string_times_3() {
  'oneoneone' == 'one' * 3
}

bool test_string_length() {
  l = 'one'.length()
  l == 3
}

bool test_string_tail() {
  'ne' == tail('one')
}

bool test_string_head() {
  'o' == head('one')
}

bool test_string_at_0() {
  'o' == 'one'.at(0)
}

bool test_string_at_1() {
  'n' == 'one'.at(1)
}

bool test_string_at_last() {
  'e' == 'one'.at(2)
}

bool test_string_special() {
  s = 'o\'ne'
  s.length() == 4 and s[1] == '\''
}

bool test_string_split() {
  s = 'one:two:three'
  s.split(':') == ['one', 'two', 'three']
}

bool test_string_split_nl() {
  s = 'one
two
three
'
  s.split('
') == ['one', 'two', 'three']
}

bool test_string_split_missing() {
  'one'.split(':') == ['one']
}

bool test_string_split_start() {
  ':one'.split(':') == ['', 'one']
}

bool test_string_replace() {
  g = 'one:two'.replace(':', ' ')
  g == 'one two'
}

bool test_string_replace_missing() {
  'one'.replace(':', ' ') == 'one'
}

bool test_string_replace_start_end() {
  ':one:'.replace(':', '') == 'one'
}

bool test_string_replace_special() {
  '\'one\''.replace('\'', '"') == '"one"'
}

bool test_replace_contains_backslash() {
  'one\\a two'.replace('\\a', ':') == 'one: two'
}

bool test_replace_backslash() {
  'one\\ two'.replace('\\', ':') == 'one: two'
}

bool test_ref_count_init() {
  _reflist.length() == 0
}

bool test_ref_count_add() {
  i = 10.ref() 
  _reflist.length() == 1
}

ref _make_ref() {
  i = 10.ref()
}

bool test_ref_deref() {
  i = 10.ref()
  i.deref() == 10
}

bool test_ref_count_import() {
  i = _make_ref()
  _reflist.length() == 1
}

bool test_list_new() {
  l = list.new()
  l.length() == 0
}

list _make_list() {
  l = list.new()
  l = l.push('one')
  l = l.push('two')
}

bool test_list_push() {
  l = _make_list()
  l.length() == 2
}

bool test_list_head() {
  l = _make_list()
  s = l.head()
  s == 'one'
}

bool test_list_join() {
  ['one', 'two', 'three'].join(', ') == 'one, two, three'
}

bool test_list_to_string() {
  ['one', 'two'].to_string() == '[one, two]'
}

bool test_list_quote() {
  ['one', 'two', 'three'].quote() == '[\'one\', \'two\', \'three\']'
}

bool test_list_eq_empty() {
  [] == []
}

bool test_list_eq_same() {
  ['one', 'two', 'three'] == ['one', 'two', 'three']
}

bool test_list_eq_different() {
  ['one', 'two', 'three'] != ['one', 'two']
}

bool test_list_tail() {
  l = _make_list()
  t = l.tail()
  t.at(0) == 'two'
}

bool test_list_length() {
  ['one', 'two', 'three'].length() == 3
}

bool test_fun_call() {
  f = int fun (int i) { 2 * i }
  f.call().with(2) == 4
}

bool test_list_map() {
  [0, 1, 2].map(int fun (int i) { 2 * i }) == [0, 2, 4]
}

bool test_list_find_present() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 1 }, 10)
  r == 1
}

bool test_list_find_absent() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 9 }, 10)
  r == 10
}

bool test_pair_new() {
  p = pair.new()
  not p.key() and p.value()
}

bool test_pair_from_lit() {
  p = 'key1': 'value1'
  p.key() == 'key1' and p.value() == 'value1'
}

bool test_map_new() {
  [:].length() == 0
}

bool test_map_at() {
  m = [
    'key1': 'value1',
    'key2': 'value2'
  ]
  m['key1'] == 'value1'
}

bool test_map_set_simple() {
  m = [:]
  m.set('key1': 'value1')
  m.length() == 1 and m.head() == 'key1': 'value1'
}

bool test_map_set_simple() {
  m = [:]
  m = m.set('key1': 'value1')
  x = 'key1': 'value1'
  m.length() == 1 and m.head() == x
}

fun multiplier(int i) {
  int fun (int j) { i * j }
}

bool test_closure() {
  f = multiplier(3)
  [0, 1, 3].map(f) == [0, 3, 9]
}

bool test_while() {
  x = 3
  y = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
  }
  y == 4
}

bool test_while_break() {
  x = 3
  y = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
    if x == 1 {
      break
    }
  }
  y == 2 and x == 1
}

bool test_while_continue() {
  x = 3
  y = 0
  z = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
    if x <= 1 {
      continue
    }
    z = z + 1
  }
  y == 4 and z == 1
}

bool test_while_nested() {
  x = 3
  z = 0
  while x >= 0 {
    x = x - 1
    y = 3
    while y >= 0 {
      y = y - 1
      z = z + 1
    }
  }
  z == 4 * 4
}

bool test_return() {
  return true
}

int returns_8() {
  if true {
    return 8
  }
  0
}

bool test_return_value() {
  returns_8() == 8
}

bool test_return_loop() {
  x = 3
  while x > 0 {
    return true
    x = x - 1
  }
  false
}
