# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# Copyright (c) 2025 Mermaidpurse

use module io
use module test

bool test_script_name() {
  program.location().has('core_test')
}

bool test_is_a() {
  false.is_a(bool)
}

bool test_bool_new() {
  b = bool.new()
  not b
}

bool test_bool_quote() {
  bool.new().quote() == 'false'
}

bool test_bool_and() {
  true and true
}

bool test_to_int_valid() {
  '10'.to_int() == 10
}

bool test_to_int_empty() {
  try {
    ''.to_int()
  } catch e {
    e.message().has('can\'t convert empty string')
  }
}

bool test_to_int_invalid() {
  try {
    'one'.to_int()
  } catch e {
    e.message().has('can\'t convert \'one\'')
  }
}

bool test_string_new() {
  string.new() == ''
}

bool test_string_quote() {
  'one'.quote() == '\'one\''
}

bool test_string_quote_with_quotes() {
  e = '\'\\\'one\\\'\\\\ \\\'two\\\'\''
  g = '\'one\'\\ \'two\''.quote()
  g == e
}

bool test_string_eq_same() {
  'same' == 'same'
}

bool test_string_times_0() {
  '' == 'one' * 0
}

bool test_string_times_1() {
  'one' == 'one' * 1
}

bool test_string_times_2() {
  'oneone' == 'one' * 2
}

bool test_string_times_3() {
  'oneoneone' == 'one' * 3
}

bool test_string_length() {
  l = 'one'.length()
  l == 3
}

bool test_string_tail() {
  'ne' == tail('one')
}

bool test_string_head() {
  'o' == head('one')
}

bool test_string_at_0() {
  'o' == 'one'.at(0)
}

bool test_string_at_1() {
  'n' == 'one'.at(1)
}

bool test_string_at_last() {
  'e' == 'one'.at(2)
}

bool test_string_special() {
  s = 'o\'ne'
  s.length() == 4 and s[1] == '\''
}

bool test_string_split() {
  s = 'one:two:three'
  s.split(':') == ['one', 'two', 'three']
}

bool test_string_split_nl() {
  s = 'one
two
three
'
  s.split('
') == ['one', 'two', 'three']
}

bool test_string_split_missing() {
  'one'.split(':') == ['one']
}

bool test_string_split_start() {
  ':one'.split(':') == ['', 'one']
}

bool test_string_replace() {
  g = 'one:two'.replace(':', ' ')
  g == 'one two'
}

bool test_string_delete_suffix() {
  deleted = 'one-two'.delete_suffix('-two')
  deleted == 'one'
}

bool test_string_replace_suffix() {
  'one.two'.replace_suffix('.two', '.TWO') == 'one.TWO'
}

bool test_string_trim() {
  '"one"'.trim('"') == 'one'
}

bool test_string_has_prefix_all() {
  'one'.has_prefix('one')
}

bool test_string_has_prefix_some() {
  'one two'.has_prefix('one')
}

bool test_string_has_prefix_none() {
  not 'one two'.has_prefix('foo')
}

bool test_string_replace_long() {
  g = 'one\\"two'.replace('\\"', '"')
  g == 'one"two'
}

bool test_string_replace_missing() {
  'one'.replace(':', ' ') == 'one'
}

bool test_string_replace_start_end() {
  ':one:'.replace(':', '') == 'one'
}

bool test_string_replace_special() {
  '\'one\''.replace('\'', '"') == '"one"'
}

bool test_replace_contains_backslash() {
  'one\\a two'.replace('\\a', ':') == 'one: two'
}

bool test_replace_backslash() {
  'one\\ two'.replace('\\', ':') == 'one: two'
}

bool test_ref_count_init() {
  _reflist.length() == 0
}

bool test_ref_count_add() {
  i = 10.ref() 
  _reflist.length() == 1
}

ref _make_ref() {
  i = 10.ref()
}

bool test_ref_deref() {
  i = 10.ref()
  i.deref() == 10
}

bool test_ref_count_import() {
  i = _make_ref()
  _reflist.length() == 1
}

bool test_list_new() {
  l = list.new()
  l.length() == 0
}

list _make_list() {
  l = list.new()
  l = l.push('one')
  l = l.push('two')
}

bool test_list_push() {
  l = _make_list()
  l.length() == 2
}

bool test_list_head() {
  l = _make_list()
  s = l.head()
  s == 'one'
}

bool test_list_join() {
  ['one', 'two', 'three'].join(', ') == 'one, two, three'
}

bool test_list_to_string() {
  ['one', 'two'].to_string() == '[one, two]'
}

bool test_list_to_string_deep() {
  l = [
    ['one', 'two'],
    ['first', 'second']
  ]
  l.to_string() == '[[one, two], [first, second]]'
}

bool test_list_quote() {
  ['one', 'two', 'three'].quote() == '[\'one\', \'two\', \'three\']'
}

bool test_list_eq_empty() {
  [] == []
}

bool test_list_eq_same() {
  ['one', 'two', 'three'] == ['one', 'two', 'three']
}

bool test_list_eq_different_length() {
  ['one', 'two', 'three'] != ['one', 'two']
}

bool test_list_set() {
  l = ['one', 'two', 'three']
  l = l.set(1, 'TWO')
  l == ['one', 'TWO', 'three']
}

bool test_list_eq_different() {
  cmp = ['one', 'two', 'three'] == ['one', 'TWO', 'three']
  !cmp
}


bool test_list_tail() {
  l = _make_list()
  t = l.tail()
  t.at(0) == 'two'
}

bool test_list_length() {
  ['one', 'two', 'three'].length() == 3
}

bool test_fun_call() {
  f = int fun (int i) { 2 * i }
  f.call().with(2) == 4
}

bool test_list_map() {
  [0, 1, 2].map(int fun (int i) { 2 * i }) == [0, 2, 4]
}

bool test_list_find_present() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 1 }, -1)
  r == 1
}

bool test_list_find_absent() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 9 }, -1)
  r == -1
}

bool test_list_has_present() {
  [0, 1, 2].has(1)
}

bool test_list_has_absent() {
  [0, 1, 2].has(3).not()
}

bool test_list_all_true() {
  [1, 2, 3, 4].all(bool fun (int i) { i > 0 })
}

bool test_list_all_false() {
  not [1, -1, 0].all(bool fun (int i) { i > 0 })
}

bool test_list_any_true() {
  [-1, 0, 2].any(bool fun (int i) { i > 0 })
}

bool test_list_any_false() {
  not [-1, 0, 2].any(bool fun (int i) { i > 10 })
}

bool test_pair_new() {
  p = pair.new()
  not p.key() and not p.value()
}

bool test_pair_from_lit() {
  p = 'key1': 'value1'
  p.key() == 'key1' and p.value() == 'value1'
}

bool test_pair_to_string() {
  p = 'one': 1
  p.to_string() == 'one: 1'
}

bool test_pair_quote() {
  p = 'one': 1
  p.quote() == '\'one\': 1'
}

bool test_map_new() {
  [:].length() == 0
}

bool test_map_at() {
  m = [
    'key1': 'value1',
    'key2': 'value2'
  ]
  m['key1'] == 'value1'
}

bool test_map_set_simple() {
  m = [:]
  m = m.set('key1': 'value1')
  x = 'key1': 'value1'
  m.length() == 1 and m.head() == x
}

bool test_map_to_string_empty() {
  [:].to_string() == '[:]'
}

bool test_map_to_string() {
  ['one': 1, 'two': 2].to_string() == '[one: 1, two: 2]'
}


fun multiplier(int i) {
  int fun (int j) { i * j }
}

bool test_closure() {
  f = multiplier(3)
  [0, 1, 3].map(f) == [0, 3, 9]
}

bool test_while() {
  x = 3
  y = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
  }
  y == 4
}

bool test_while_break() {
  x = 3
  y = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
    if x == 1 {
      break
    }
  }
  y == 2 and x == 1
}

bool test_while_continue() {
  x = 3
  y = 0
  z = 0
  while x >= 0 {
    y = y + 1
    x = x - 1
    if x <= 1 {
      continue
    }
    z = z + 1
  }
  y == 4 and z == 1
}

bool test_while_nested() {
  x = 3
  z = 0
  while x >= 0 {
    x = x - 1
    y = 3
    while y >= 0 {
      y = y - 1
      z = z + 1
    }
  }
  z == 4 * 4
}

bool test_return() {
  return true
}

int returns_8() {
  if true {
    return 8
  }
  0
}

bool test_return_value() {
  returns_8() == 8
}

bool test_return_loop() {
  x = 3
  while x > 0 {
    return true
    x = x - 1
  }
  false
}

bool throw_something() {
  throw 'something happen'
}

bool test_throw() {
  try {
    throw_something()
  } catch e {
    e.message().has('something')
  }
}

bool test_assert() {
  try {
    3.assert(string)
  } catch e {
    e.message().has('Expected type \'string\', got \'int\'')
  }
}

bool test_command_nonexistent() {
  i = command.get('foobanza')
  i.name() == 'foobanza' and !i.is_available()
}

bool test_command_builtin() {
  i = command.get('type')
  i.location() == 'type' and !i.is_external() and i.is_available()
}

bool test_command_external() {
  i = command.get('ruby')
  i.location().has('/ruby') and i.is_external() and i.is_available()
}

bool test_command_result() {
  cr = command_result.new()
  cr.exitcode() == 0 and cr.output() == ''
}

bool test_command_run_builtin() {
  c = command.get('type')
  result = c.run(['type'])
  result.output() == 'type is a shell builtin' and result.is_success()
}

bool test_command_run_raw() {
  c = command.get(':')
  result = c.run_raw([])
  result.is_success()
}

bool test_command_run_lines() {
  c = command.get('export')
  result = c.run(['-p'])
  result.lines().all(bool fun (string s) { s.has_prefix('export') })
}
