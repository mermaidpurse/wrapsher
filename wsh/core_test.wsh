meta doc 'tests for core module'

use module io
use module test

bool test_bool_new() {
  b = bool.new()
  not b
}

bool test_bool_and() {
  true and true
}

bool test_string_eq_same() {
  'same' == 'same'
}

bool test_string_times_0() {
  '' == 'one' * 0
}

bool test_string_times_1() {
  'one' == 'one' * 1
}

bool test_string_times_2() {
  'oneone' == 'one' * 2
}

bool test_string_times_3() {
  'oneoneone' == 'one' * 3
}

bool test_string_length() {
  l = 'one'.length()
  l == 3
}

bool test_string_tail() {
  'ne' == tail('one')
}

bool test_string_head() {
  'o' == head('one')
}

bool test_string_at_0() {
  'o' == 'one'.at(0)
}

bool test_string_at_1() {
  'n' == 'one'.at(1)
}

bool test_string_at_last() {
  'e' == 'one'.at(2)
}

bool test_string_special() {
  s = 'o\'ne'
  s.length() == 4 and s[1] == '\''
}

bool test_ref_count_init() {
  _reflist.length() == 0
}

bool test_ref_count_add() {
  i = 10.ref() 
  _reflist.length() == 1
}

ref _make_ref() {
  i = 10.ref()
}

bool test_ref_deref() {
  i = 10.ref()
  i.deref() == 10
}

bool test_ref_count_import() {
  i = _make_ref()
  _reflist.length() == 1
}

bool test_list_new() {
  l = list.new()
  l.length() == 0
}

list _make_list() {
  l = list.new()
  l = l.push('one')
  l = l.push('two')
}

bool test_list_push() {
  l = _make_list()
  l.length() == 2
}

bool test_list_head() {
  l = _make_list()
  s = l.head()
  s == 'one'
}

bool test_list_eq_empty() {
  [] == []
}

bool test_list_eq_same() {
  ['one', 'two', 'three'] == ['one', 'two', 'three']
}

bool test_list_eq_different() {
  ['one', 'two', 'three'] != ['one', 'two']
}

bool test_list_tail() {
  l = _make_list()
  t = l.tail()
  t.at(0) == 'two'
}

bool test_list_length() {
  ['one', 'two', 'three'].length() == 3
}

bool test_fun_call() {
  f = int fun (int i) { 2 * i }
  f.call().with(2) == 4
}

bool test_list_map() {
  [0, 1, 2].map(int fun (int i) { 2 * i }) == [0, 2, 4]
}

# TODO: Need negative ints
bool test_list_find_present() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 1 }, 10)
  r == 1
}

bool test_list_find_absent() {
  r = [0, 1, 2, 4].find(bool fun (int i) { i == 9 }, 10)
  r == 10
}

bool test_pair_new() {
  p = pair.new()
  not p.key() and p.value()
}

bool test_pair_from_lit() {
  p = 'key1': 'value1'
  p.key() == 'key1' and p.value() == 'value1'
}

bool test_map_new() {
  [:].length() == 0
}

bool test_map_at() {
  m = [
    'key1': 'value1',
    'key2': 'value2'
  ]
  m['key1'] == 'value1'
}

bool test_map_set_simple() {
  m = [:]
  m.set('key1': 'value1')
  m.length() == 1 and m.head() == 'key1': 'value1'
}

bool test_map_set_simple() {
  m = [:]
  m = m.set('key1': 'value1')
  x = 'key1': 'value1'
  m.length() == 1 and m.head() == x
}
